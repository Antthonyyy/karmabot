Задача: Создать продвинутую, масштабируемую систему напоминаний (концептуальная версия)
Цель: Реализовать гибкую систему напоминаний, где пользователь может выбирать из готовых режимов или настраивать свой собственный. Архитектура должна быть надежной, безопасной и легко расширяемой в будущем.

Шаг 1: Модификация схемы базы данных
Необходимо обновить структуру базы данных для поддержки новой функциональности.

Таблица users:

Добавьте поля для хранения выбранного режима (reminderMode), количества ежедневных принципов (dailyPrinciplesCount) и часового пояса пользователя (timezone).

Удалите устаревшие поля для утренних и вечерних напоминаний.

Новая таблица reminderSchedules:

Создайте эту таблицу для хранения кастомных и предустановленных расписаний каждого пользователя.

Она должна содержать ID пользователя, время напоминания (HH:MM), тип (принцип или рефлексия) и статус (включено/выключено).

Таблица userPrinciples:

Добавьте поле principleOrder для отслеживания порядкового номера принципа в течение дня (первый, второй и т.д.).

Шаг 2: Централизация логики режимов на бэкенде
Чтобы избежать дублирования и упростить управление, вся информация о режимах должна храниться и управляться на сервере.

Создайте конфигурацию режимов на сервере: Определите предустановленные режимы ("Інтенсивний", "Збалансований", "Легкий") в виде централизованной конфигурации на бэкенде. Каждый режим должен иметь название, описание, количество принципов в день и точное расписание.

Создайте API-эндпоинт для получения режимов: Реализуйте эндпоинт GET /api/reminders/modes, который будет отдавать фронтенду список всех доступных предустановленных режимов из этой конфигурации.

Шаг 3: Разработка фронтенд-компонентов
Пользовательский интерфейс должен быть интуитивно понятным и реактивным.

Компонент выбора режимов (ReminderModeSelector):

Этот компонент должен при загрузке запрашивать список режимов с эндпоинта /api/reminders/modes.

Он должен отображать каждый полученный режим в виде красивой интерактивной карточки.

Дополнительно должна отображаться статичная карточка для "Кастомного" режима.

Необходимо предусмотреть состояния загрузки и ошибки.

Компонент редактора расписания (CustomScheduleEditor):

Этот компонент предназначен для создания и редактирования полностью кастомного расписания.

Пользователь должен иметь возможность добавлять и удалять напоминания, устанавливать для каждого точное время и выбирать его тип (принцип или рефлексия).

Шаг 4: Интеграция в процесс онбординга
Новые компоненты должны быть встроены в процесс первоначальной настройки приложения для пользователя.

Во время онбординга покажите пользователю экран с компонентом выбора режимов.

Если пользователь выбирает один из предустановленных режимов, он переходит к следующему шагу.

Если пользователь выбирает "Кастомный" режим, ему отображается компонент редактора расписания для настройки, и только после этого он переходит дальше.

Шаг 5: Реализация API для сохранения настроек
Необходимо создать надежный механизм сохранения пользовательского выбора.

Создайте API-эндпоинт POST /api/user/setup-reminders.

Ключевое требование: Все операции с базой данных внутри этого эндпоинта (обновление профиля пользователя, удаление старых расписаний и создание новых) должны быть обернуты в единую транзакцию. Это гарантирует, что данные пользователя либо обновятся полностью, либо останутся в исходном состоянии в случае сбоя.

Эндпоинт должен принимать выбранный режим и, если режим кастомный, массив с его расписанием.

Шаг 6: Обновление фонового сервиса отправки напоминаний
Сервис, отвечающий за отправку уведомлений, должен быть адаптирован под новую логику.

Сервис должен теперь запрашивать данные из новой таблицы reminderSchedules, чтобы определить, кому и какое напоминание отправлять в текущую минуту.

Он должен уметь различать типы напоминаний (принцип и рефлексия) и запускать соответствующую логику для каждого.

При запросе данных из БД также необходимо получать информацию о часовом поясе пользователя для будущей реализации этой функциональности.
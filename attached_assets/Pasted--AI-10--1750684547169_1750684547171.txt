–°–æ–∑–¥–∞–π AI-—Å–µ—Ä–≤–∏—Å —Å –∫–æ–Ω—Ç—Ä–æ–ª–µ–º –±—é–¥–∂–µ—Ç–∞ ($10/–º–µ—Å—è—Ü) –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π —á–∞—Ç–∞ –¥–ª—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è "–ö–∞—Ä–º—ñ—á–Ω–∏–π —â–æ–¥–µ–Ω–Ω–∏–∫".

1. –°–æ–∑–¥–∞–π —Å–µ—Ä–≤–∏—Å –∫–æ–Ω—Ç—Ä–æ–ª—è –±—é–¥–∂–µ—Ç–∞ `/server/services/budget-monitor.ts`:
```typescript
import { db } from '../db';
import { aiRequests } from '../db/schema';
import { gte, sql } from 'drizzle-orm';

export class BudgetMonitor {
  private readonly MONTHLY_LIMIT = 10; // $10
  private readonly COST_PER_1K_TOKENS = {
    'gpt-3.5-turbo': 0.0015, // $1.50 per 1M tokens
    'gpt-4': 0.03 // $30 per 1M tokens  
  };

  async checkMonthlyBudget(): Promise<{ used: number; remaining: number; percentage: number }> {
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);
    
    const [result] = await db
      .select({ totalCost: sql<number>`COALESCE(SUM(cost), 0)` })
      .from(aiRequests)
      .where(gte(aiRequests.createdAt, startOfMonth));
    
    const used = result?.totalCost || 0;
    const remaining = Math.max(0, this.MONTHLY_LIMIT - used);
    const percentage = (used / this.MONTHLY_LIMIT) * 100;
    
    return { used, remaining, percentage };
  }

  async canMakeRequest(estimatedTokens: number = 200, model: string = 'gpt-3.5-turbo'): Promise<boolean> {
    const { remaining } = await this.checkMonthlyBudget();
    const estimatedCost = (estimatedTokens / 1000) * this.COST_PER_1K_TOKENS[model];
    
    if (remaining < estimatedCost) {
      console.warn(`‚ö†Ô∏è –ë—é–¥–∂–µ—Ç –ø–æ—á—Ç–∏ –∏—Å—á–µ—Ä–ø–∞–Ω! –û—Å—Ç–∞–ª–æ—Å—å: $${remaining.toFixed(2)}`);
      return false;
    }
    
    return true;
  }

  async recordUsage(userId: number, type: string, tokens: number, model: string = 'gpt-3.5-turbo') {
    const cost = (tokens / 1000) * this.COST_PER_1K_TOKENS[model];
    
    await db.insert(aiRequests).values({
      userId,
      type,
      tokensUsed: tokens,
      cost,
      model,
      createdAt: new Date()
    });
    
    const { used, percentage } = await this.checkMonthlyBudget();
    
    if (percentage > 80) {
      console.warn(`‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ ${percentage.toFixed(0)}% –º–µ—Å—è—á–Ω–æ–≥–æ –±—é–¥–∂–µ—Ç–∞ ($${used.toFixed(2)}/$${this.MONTHLY_LIMIT})`);
    }
  }

  async getUserMonthlyUsage(userId: number): Promise<{ count: number; tokens: number; cost: number }> {
    const startOfMonth = new Date();
    startOfMonth.setDate(1);
    startOfMonth.setHours(0, 0, 0, 0);
    
    const [result] = await db
      .select({
        count: sql<number>`COUNT(*)`,
        tokens: sql<number>`COALESCE(SUM(tokens_used), 0)`,
        cost: sql<number>`COALESCE(SUM(cost), 0)`
      })
      .from(aiRequests)
      .where(
        sql`user_id = ${userId} AND created_at >= ${startOfMonth}`
      );
    
    return {
      count: result?.count || 0,
      tokens: result?.tokens || 0,
      cost: result?.cost || 0
    };
  }
}

–û–±–Ω–æ–≤–∏ AI-—Å–µ—Ä–≤–∏—Å /server/services/ai-assistant.ts:

typescriptimport { OpenAI } from 'openai';
import { db } from '../db';
import { users, journalEntries, aiRequests, aiCache } from '../db/schema';
import { eq, and, gte, desc } from 'drizzle-orm';
import { createHash } from 'crypto';
import { BudgetMonitor } from './budget-monitor';
import { SubscriptionService } from './subscription.service';

export class AIAssistant {
  private openai: OpenAI;
  private budgetMonitor: BudgetMonitor;
  private subscriptionService: SubscriptionService;

  constructor() {
    this.openai = new OpenAI({ apiKey: process.env.api_key_openai });
    this.budgetMonitor = new BudgetMonitor();
    this.subscriptionService = new SubscriptionService();
  }

  private async checkUserLimits(userId: number, type: 'advisor' | 'chat') {
    const subscription = await this.subscriptionService.getUserSubscription(userId);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ —Ñ—É–Ω–∫—Ü–∏–∏
    if (type === 'chat' && !subscription.features.aiChat) {
      throw new Error('AI-—á–∞—Ç –¥–æ—Å—Ç—É–ø–Ω–∏–π –ª–∏—à–µ –¥–ª—è —Ç–∞—Ä–∏—Ñ—É –ü—Ä–æ');
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç—ã –¥–ª—è Plus —Ç–∞—Ä–∏—Ñ–∞
    if (subscription.plan === 'plus' && type === 'advisor') {
      const usage = await this.budgetMonitor.getUserMonthlyUsage(userId);
      if (usage.count >= 5) {
        throw new Error('–õ—ñ–º—ñ—Ç AI-–ø–æ—Ä–∞–¥ –≤–∏—á–µ—Ä–ø–∞–Ω–æ (5/–º—ñ—Å—è—Ü—å). –û–Ω–æ–≤—ñ—Ç—å –¥–æ —Ç–∞—Ä–∏—Ñ—É –ü—Ä–æ!');
      }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—â–∏–π –±—é–¥–∂–µ—Ç
    if (!await this.budgetMonitor.canMakeRequest()) {
      throw new Error('–ú—ñ—Å—è—á–Ω–∏–π –±—é–¥–∂–µ—Ç AI –≤–∏—á–µ—Ä–ø–∞–Ω–æ. –°–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –º—ñ—Å—è—Ü—è.');
    }
  }

  private async getCachedResponse(hash: string): Promise<string | null> {
    const cached = await db.query.aiCache.findFirst({
      where: eq(aiCache.questionHash, hash)
    });
    
    if (cached && cached.expiresAt && new Date(cached.expiresAt) > new Date()) {
      return cached.response;
    }
    
    return null;
  }

  private async cacheResponse(hash: string, response: string, language: string = 'uk') {
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7); // –ö—ç—à –Ω–∞ 7 –¥–Ω–µ–π
    
    await db.insert(aiCache).values({
      questionHash: hash,
      response,
      language,
      expiresAt,
      createdAt: new Date()
    }).onConflictDoUpdate({
      target: aiCache.questionHash,
      set: {
        response,
        expiresAt,
        createdAt: new Date()
      }
    });
  }

  async chat(userId: number, messages: { role: string; content: string }[], language: string = 'uk'): Promise<string> {
    try {
      await this.checkUserLimits(userId, 'chat');
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
      const lastMessage = messages[messages.length - 1].content;
      const questionHash = createHash('md5').update(`${lastMessage}_${language}`).digest('hex');
      
      const cached = await this.getCachedResponse(questionHash);
      if (cached) {
        console.log('üíæ Returning cached response');
        return cached;
      }

      // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
      const entries = await db.query.journalEntries.findMany({
        where: eq(journalEntries.userId, userId),
        orderBy: desc(journalEntries.createdAt),
        limit: 10
      });
      
      const entriesText = entries.map(e => 
        `${e.category}: ${e.description} (–∫–∞—Ä–º–∞: ${e.karmaPoints > 0 ? '+' : ''}${e.karmaPoints})`
      ).join('\n');

      const systemPrompt = language === 'uk' 
        ? `–¢–∏ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–∏–π –ø—Å–∏—Ö–æ–ª–æ–≥-–∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç, —è–∫–∏–π —Å–ø–µ—Ü—ñ–∞–ª—ñ–∑—É—î—Ç—å—Å—è –Ω–∞ —Ä–æ–∑–≤–∏—Ç–∫—É –ø–æ–∑–∏—Ç–∏–≤–Ω–æ—ó –∫–∞—Ä–º–∏ —Ç–∞ –æ—Å–æ–±–∏—Å—Ç—ñ—Å–Ω–æ–º—É –∑—Ä–æ—Å—Ç–∞–Ω–Ω—ñ. 
           –í—ñ–¥–ø–æ–≤—ñ–¥–∞–π —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é –º–æ–≤–æ—é, –±—É–¥—å –µ–º–ø–∞—Ç—ñ–π–Ω–∏–º —Ç–∞ –ø—ñ–¥—Ç—Ä–∏–º—É—é—á–∏–º. 
           –î–∞–≤–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ñ, –ø—Ä–∞–∫—Ç–∏—á–Ω—ñ –ø–æ—Ä–∞–¥–∏.
           –û—Å—å –æ—Å—Ç–∞–Ω–Ω—ñ –∑–∞–ø–∏—Å–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ —â–æ–¥–µ–Ω–Ω–∏–∫–∞:\n${entriesText}`
        : `You are a professional psychologist consultant specializing in positive karma development and personal growth.
           Be empathetic and supportive. Give specific, practical advice.
           Here are the user's recent journal entries:\n${entriesText}`;

      const completion = await this.openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: systemPrompt },
          ...messages
        ],
        max_tokens: 200,
        temperature: 0.7
      });

      const response = completion.choices[0].message.content || 
        (language === 'uk' ? '–ü—Ä–æ–¥–æ–≤–∂—É–π —É —Ç–æ–º—É –∂ –¥—É—Å—ñ! üåü' : 'Keep going! üåü');
      
      // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
      const tokensUsed = completion.usage?.total_tokens || 200;
      await this.budgetMonitor.recordUsage(userId, 'chat', tokensUsed);
      
      // –ö—ç—à–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
      await this.cacheResponse(questionHash, response, language);
      
      return response;
    } catch (error) {
      console.error('AI Chat error:', error);
      throw error;
    }
  }

  async analyzeUserEntries(userId: number, language: string = 'uk'): Promise<string> {
    try {
      await this.checkUserLimits(userId, 'advisor');
      
      const entries = await db.query.journalEntries.findMany({
        where: eq(journalEntries.userId, userId),
        orderBy: desc(journalEntries.createdAt),
        limit: 20
      });

      if (entries.length === 0) {
        return language === 'uk' 
          ? '–ü–æ—á–Ω–∏ –≤–µ—Å—Ç–∏ —â–æ–¥–µ–Ω–Ω–∏–∫, —â–æ–± –æ—Ç—Ä–∏–º–∞—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –ø–æ—Ä–∞–¥–∏!' 
          : 'Start journaling to get personalized advice!';
      }

      // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω—ã
      const positiveCount = entries.filter(e => e.karmaPoints > 0).length;
      const totalKarma = entries.reduce((sum, e) => sum + e.karmaPoints, 0);
      const categories = entries.map(e => e.category);
      
      const entriesText = entries.map(e => 
        `${e.category}: ${e.description} (–∫–∞—Ä–º–∞: ${e.karmaPoints})`
      ).join('\n');

      const prompt = language === 'uk'
        ? `–ü—Ä–æ–∞–Ω–∞–ª—ñ–∑—É–π —Ü—ñ –∑–∞–ø–∏—Å–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —Ç–∞ –¥–∞–π –∫–æ—Ä–æ—Ç–∫—É –ø–æ—Ä–∞–¥—É (–º–∞–∫—Å. 3 —Ä–µ—á–µ–Ω–Ω—è):
           –ü–æ–∑–∏—Ç–∏–≤–Ω–∏—Ö –≤—á–∏–Ω–∫—ñ–≤: ${positiveCount}/${entries.length}
           –ó–∞–≥–∞–ª—å–Ω–∞ –∫–∞—Ä–º–∞: ${totalKarma}
           –ó–∞–ø–∏—Å–∏:\n${entriesText}`
        : `Analyze these user entries and give brief advice (max 3 sentences):
           Positive actions: ${positiveCount}/${entries.length}
           Total karma: ${totalKarma}
           Entries:\n${entriesText}`;

      const completion = await this.openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 100,
        temperature: 0.7
      });

      const response = completion.choices[0].message.content || 
        (language === 'uk' ? '–ü—Ä–æ–¥–æ–≤–∂—É–π –≤–µ—Å—Ç–∏ —â–æ–¥–µ–Ω–Ω–∏–∫!' : 'Keep journaling!');
      
      // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
      const tokensUsed = completion.usage?.total_tokens || 150;
      await this.budgetMonitor.recordUsage(userId, 'advisor', tokensUsed);
      
      return response;
    } catch (error) {
      console.error('AI Advisor error:', error);
      throw error;
    }
  }
}

–°–æ–∑–¥–∞–π —Ä–æ—É—Ç–µ—Ä –¥–ª—è AI /server/routes/ai.ts:

typescriptimport { Router } from 'express';
import { authenticate } from '../middleware/auth';
import { AIAssistant } from '../services/ai-assistant';
import { BudgetMonitor } from '../services/budget-monitor';

const router = Router();
const aiAssistant = new AIAssistant();
const budgetMonitor = new BudgetMonitor();

// AI —á–∞—Ç
router.post('/api/ai/chat', authenticate, async (req, res) => {
  try {
    const { messages, language = 'uk' } = req.body;
    
    // –í–∞–ª–∏–¥–∞—Ü–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
    if (!messages || !Array.isArray(messages)) {
      return res.status(400).json({ error: 'Invalid messages format' });
    }
    
    for (const msg of messages) {
      if (!msg.role || !msg.content) {
        return res.status(400).json({ error: 'Invalid message structure' });
      }
      if (!['user', 'assistant'].includes(msg.role)) {
        return res.status(400).json({ error: 'Invalid message role' });
      }
      if (msg.content.length > 500) {
        return res.status(400).json({ error: 'Message too long (max 500 chars)' });
      }
    }
    
    const reply = await aiAssistant.chat(req.user.id, messages, language);
    res.json({ reply });
  } catch (error) {
    console.error('AI chat error:', error);
    
    if (error.message.includes('—Ç–∞—Ä–∏—Ñ—É –ü—Ä–æ') || error.message.includes('Pro plan')) {
      return res.status(403).json({ error: error.message, code: 'SUBSCRIPTION_REQUIRED' });
    }
    
    if (error.message.includes('–õ—ñ–º—ñ—Ç') || error.message.includes('limit')) {
      return res.status(403).json({ error: error.message, code: 'LIMIT_EXCEEDED' });
    }
    
    if (error.message.includes('–±—é–¥–∂–µ—Ç') || error.message.includes('budget')) {
      return res.status(503).json({ error: error.message, code: 'BUDGET_EXCEEDED' });
    }
    
    res.status(500).json({ error: 'AI service unavailable' });
  }
});

// AI –∞–Ω–∞–ª–∏–∑ –∑–∞–ø–∏—Å–µ–π
router.post('/api/ai/analyze', authenticate, async (req, res) => {
  try {
    const { language = 'uk' } = req.body;
    const advice = await aiAssistant.analyzeUserEntries(req.user.id, language);
    res.json({ advice });
  } catch (error) {
    console.error('AI analyze error:', error);
    
    if (error.message.includes('–õ—ñ–º—ñ—Ç') || error.message.includes('limit')) {
      return res.status(403).json({ error: error.message, code: 'LIMIT_EXCEEDED' });
    }
    
    if (error.message.includes('–±—é–¥–∂–µ—Ç') || error.message.includes('budget')) {
      return res.status(503).json({ error: error.message, code: 'BUDGET_EXCEEDED' });
    }
    
    res.status(500).json({ error: 'AI service unavailable' });
  }
});

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è AI
router.get('/api/ai/usage', authenticate, async (req, res) => {
  try {
    const usage = await budgetMonitor.getUserMonthlyUsage(req.user.id);
    const budget = await budgetMonitor.checkMonthlyBudget();
    
    res.json({
      user: usage,
      system: {
        ...budget,
        limit: 10
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// –ê–¥–º–∏–Ω—Å–∫–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –±—é–¥–∂–µ—Ç–∞
router.get('/api/admin/ai-budget', authenticate, async (req, res) => {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∞–¥–º–∏–Ω
  if (req.user.email !== process.env.ADMIN_EMAIL) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  try {
    const budget = await budgetMonitor.checkMonthlyBudget();
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
    const topUsers = await db.query.aiRequests.findMany({
      columns: {
        userId: true,
        cost: true,
        tokensUsed: true
      },
      orderBy: desc(aiRequests.cost),
      limit: 10
    });
    
    res.json({
      budget: {
        ...budget,
        limit: 10,
        usedFormatted: `$${budget.used.toFixed(2)}`,
        remainingFormatted: `$${budget.remaining.toFixed(2)}`
      },
      topUsers
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

export default router;

–î–æ–±–∞–≤—å —Ä–æ—É—Ç–µ—Ä –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–π–ª —Å–µ—Ä–≤–µ—Ä–∞ /server/index.ts:

typescriptimport aiRoutes from './routes/ai';

// –ü–æ—Å–ª–µ –¥—Ä—É–≥–∏—Ö —Ä–æ—É—Ç–æ–≤
app.use(aiRoutes);

–°–æ–∑–¥–∞–π –∫—Ä–æ–Ω-–∑–∞–¥–∞—á—É –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞ /server/jobs/cleanup-cache.ts:

typescriptimport { db } from '../db';
import { aiCache } from '../db/schema';
import { lt } from 'drizzle-orm';

export async function cleanupExpiredCache() {
  try {
    const deleted = await db.delete(aiCache)
      .where(lt(aiCache.expiresAt, new Date()))
      .returning();
    
    if (deleted.length > 0) {
      console.log(`üßπ –û—á–∏—â–µ–Ω–æ ${deleted.length} –∑–∞–ø–∏—Å–µ–π –∏–∑ –∫—ç—à–∞ AI`);
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞:', error);
  }
}

// –ó–∞–ø—É—Å–∫–∞—Ç—å –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
setInterval(cleanupExpiredCache, 24 * 60 * 60 * 1000);
–ü—Ä–æ–≤–µ—Ä—å:

–ó–∞–ø—É—Å—Ç–∏ —Å–µ—Ä–≤–µ—Ä npm run dev
–î–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –ø–æ–¥–ø–∏—Å–∫–æ–π Pro –æ—Ç–ø—Ä–∞–≤—å POST –∑–∞–ø—Ä–æ—Å –Ω–∞ /api/ai/chat:
json{
  "messages": [{"role": "user", "content": "–Ø–∫ –ø–æ–∫—Ä–∞—â–∏—Ç–∏ –∫–∞—Ä–º—É?"}],
  "language": "uk"
}

–ü—Ä–æ–≤–µ—Ä—å /api/ai/usage –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
–£–±–µ–¥–∏—Å—å, —á—Ç–æ –≤ —Ç–∞–±–ª–∏—Ü–µ ai_requests –ø–æ—è–≤–ª—è—é—Ç—Å—è –∑–∞–ø–∏—Å–∏ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º cost
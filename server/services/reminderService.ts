import cron from 'node-cron';
import { storage } from '../storage.js';
import { bot } from '../bot/index.js';

export class ReminderService {
  constructor() {
    this.initializeSchedules();
  }

  private initializeSchedules() {
    // Antidote reminders - 30 minutes before main reminders
    cron.schedule('30 8 * * *', async () => {
      await this.sendAntidoteReminders('morning');
    });

    cron.schedule('30 14 * * *', async () => {
      await this.sendAntidoteReminders('afternoon');
    });

    cron.schedule('30 19 * * *', async () => {
      await this.sendAntidoteReminders('evening');
    });

    // Morning reminders (9:00 AM)
    cron.schedule('0 9 * * *', async () => {
      await this.sendMorningReminders();
    });

    // Afternoon reminders (3:00 PM)
    cron.schedule('0 15 * * *', async () => {
      await this.sendAfternoonReminders();
    });

    // Evening reminders (8:00 PM)
    cron.schedule('0 20 * * *', async () => {
      await this.sendEveningReminders();
    });

    console.log('üîî Reminder service scheduled');
  }

  private async sendAntidoteReminders(timeOfDay: 'morning' | 'afternoon' | 'evening') {
    const activeUsers = await storage.getActiveUsers();
    
    const timeMessages = {
      morning: 'üåÖ –î–æ–±—Ä–æ–≥–æ —Ä–∞–Ω–∫—É!',
      afternoon: '‚òÄÔ∏è –î–æ–±—Ä–∏–π –¥–µ–Ω—å!',
      evening: 'üåô –î–æ–±—Ä–∏–π –≤–µ—á—ñ—Ä!'
    };

    const timeAdvice = {
      morning: '–ü–µ—Ä–µ–¥ –ø–æ—á–∞—Ç–∫–æ–º –¥–Ω—è –ø–æ–¥—É–º–∞–π - —á–∏ —î —É —Ç–µ–±–µ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ñ –¥—É–º–∫–∏, —è–∫—ñ –º–æ–∂—É—Ç—å –∑–∞–≤–∞–∂–∞—Ç–∏? –°—Ç–≤–æ—Ä–∏ –∞–Ω—Ç–∏–¥–æ—Ç!',
      afternoon: '–£ —Å–µ—Ä–µ–¥–∏–Ω—ñ –¥–Ω—è –≤–∞—Ä—Ç–æ –∑—É–ø–∏–Ω–∏—Ç–∏—Å—è —ñ –ø–µ—Ä–µ–æ—Å–º–∏—Å–ª–∏—Ç–∏. –ß–∏ –ø–æ—Ç—Ä—ñ–±–µ–Ω —Ç–æ–±—ñ –∞–Ω—Ç–∏–¥–æ—Ç –≤—ñ–¥ –Ω–µ–≥–∞—Ç–∏–≤—É?',
      evening: '–ü–µ—Ä–µ–¥ —Å–Ω–æ–º –¥–æ–±—Ä–µ –æ—á–∏—Å—Ç–∏—Ç–∏ —Ä–æ–∑—É–º –≤—ñ–¥ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏—Ö –¥—É–º–æ–∫. –ó–∞–ø–∏—à–∏ –∞–Ω—Ç–∏–¥–æ—Ç –¥–æ —Ç–æ–≥–æ, —â–æ —Ç—É—Ä–±—É—î.'
    };
    
    for (const user of activeUsers) {
      if (user.notificationType === 'daily' || user.notificationType === 'intensive') {
        try {
          await bot.sendMessage(
            parseInt(user.telegramId!),
            `${timeMessages[timeOfDay]} ${user.firstName}!\n\n` +
            `üõ°Ô∏è –ß–∞—Å –¥–ª—è –∞–Ω—Ç–∏–¥–æ—Ç—É!\n\n` +
            `${timeAdvice[timeOfDay]}\n\n` +
            `–ê–Ω—Ç–∏–¥–æ—Ç - —Ü–µ –ø–æ–∑–∏—Ç–∏–≤–Ω–∞ –¥—É–º–∫–∞ –∞–±–æ –¥—ñ—è, —è–∫–∞ –Ω–µ–π—Ç—Ä–∞–ª—ñ–∑—É—î –Ω–µ–≥–∞—Ç–∏–≤ —ñ –ø–æ–≤–µ—Ä—Ç–∞—î —Ç–µ–±–µ –¥–æ –≥–∞—Ä–º–æ–Ω—ñ—ó. üíö`,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: "üõ°Ô∏è –î–æ–¥–∞—Ç–∏ –∞–Ω—Ç–∏–¥–æ—Ç", callback_data: "add_antidote" }],
                  [{ text: "üì± –í—ñ–¥–∫—Ä–∏—Ç–∏ –¥–æ–¥–∞—Ç–æ–∫", web_app: { url: process.env.FRONTEND_URL } }]
                ]
              }
            }
          );
        } catch (error) {
          console.error(`Failed to send antidote reminder to user ${user.id}:`, error);
        }
      }
    }
  }

  private async sendMorningReminders() {
    const activeUsers = await storage.getActiveUsers();
    
    for (const user of activeUsers) {
      if (user.notificationType === 'daily' || user.notificationType === 'intensive') {
        try {
          await bot.sendMessage(
            parseInt(user.telegramId!),
            `üåÖ –î–æ–±—Ä–æ–≥–æ —Ä–∞–Ω–∫—É, ${user.firstName}!\n\n` +
            `–ù–æ–≤–∏–π –¥–µ–Ω—å - –Ω–æ–≤–∞ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å —Ç–≤–æ—Ä–∏—Ç–∏ –¥–æ–±—Ä–æ.\n` +
            `–°—å–æ–≥–æ–¥–Ω—ñ—à–Ω—ñ–π –ø—Ä–∏–Ω—Ü–∏–ø: ${user.currentPrinciple}/10\n\n` +
            `–°–ø—Ä–æ–±—É–π —Å—å–æ–≥–æ–¥–Ω—ñ –∑—Ä–æ–±–∏—Ç–∏ —â–æ–Ω–∞–π–º–µ–Ω—à–µ –æ–¥–Ω—É –¥–æ–±—Ä—É —Å–ø—Ä–∞–≤—É! üíù`,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: "üìù –î–æ–¥–∞—Ç–∏ –∑–∞–ø–∏—Å", callback_data: "add_entry" }],
                  [{ text: "üì± –í—ñ–¥–∫—Ä–∏—Ç–∏ –¥–æ–¥–∞—Ç–æ–∫", web_app: { url: process.env.FRONTEND_URL } }]
                ]
              }
            }
          );
        } catch (error) {
          console.error(`Failed to send morning reminder to user ${user.id}:`, error);
        }
      }
    }
  }

  private async sendAfternoonReminders() {
    const activeUsers = await storage.getActiveUsers();
    
    for (const user of activeUsers) {
      if (user.notificationType === 'intensive') {
        try {
          await bot.sendMessage(
            parseInt(user.telegramId!),
            `‚òÄÔ∏è ${user.firstName}, —è–∫ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –¥–µ–Ω—å?\n\n` +
            `–ß–∞—Å –¥–ª—è –∫–æ—Ä–æ—Ç–∫–æ—ó —Ä–µ—Ñ–ª–µ–∫—Å—ñ—ó:\n` +
            `‚Ä¢ –©–æ –¥–æ–±—Ä–æ–≥–æ —Ç–∏ –≤–∂–µ –∑—Ä–æ–±–∏–≤ —Å—å–æ–≥–æ–¥–Ω—ñ?\n` +
            `‚Ä¢ –©–æ –º–æ–∂–µ—à –ø–æ–∫—Ä–∞—â–∏—Ç–∏ —É –¥—Ä—É–≥—ñ–π –ø–æ–ª–æ–≤–∏–Ω—ñ –¥–Ω—è?\n\n` +
            `–ó–∞–ø–∏—Å—É–π —Å–≤–æ—ó –¥—É–º–∫–∏ –≤ —â–æ–¥–µ–Ω–Ω–∏–∫! üìñ`,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: "üìä –ú—ñ–π –ø—Ä–æ–≥—Ä–µ—Å", callback_data: "stats" }],
                  [{ text: "üí¨ AI-–ø–æ—Ä–∞–¥–∞", callback_data: "ai_advice" }]
                ]
              }
            }
          );
        } catch (error) {
          console.error(`Failed to send afternoon reminder to user ${user.id}:`, error);
        }
      }
    }
  }

  private async sendEveningReminders() {
    const activeUsers = await storage.getActiveUsers();
    
    for (const user of activeUsers) {
      if (user.notificationType === 'daily' || user.notificationType === 'intensive') {
        try {
          const userStats = await storage.getUserStats(user.id);
          const todayEntries = userStats?.totalEntries || 0;
          
          let message = `üåô –î–æ–±—Ä–∏–π –≤–µ—á—ñ—Ä, ${user.firstName}!\n\n`;
          
          if (todayEntries === 0) {
            message += `–°—å–æ–≥–æ–¥–Ω—ñ —Ç–∏ —â–µ –Ω–µ –¥–æ–¥–∞–≤ –∑–∞–ø–∏—Å—ñ–≤ —É —â–æ–¥–µ–Ω–Ω–∏–∫.\n` +
              `–ó–≥–∞–¥–∞–π - —â–æ –¥–æ–±—Ä–æ–≥–æ —Å—Ç–∞–ª–æ—Å—è —Å—å–æ–≥–æ–¥–Ω—ñ?\n` +
              `–ù–∞–≤—ñ—Ç—å –º–∞–ª–µ–Ω—å–∫–∞ —Å–ø—Ä–∞–≤–∞ –º–∞—î –∑–Ω–∞—á–µ–Ω–Ω—è! ‚ú®`;
          } else {
            message += `–°—å–æ–≥–æ–¥–Ω—ñ —Ç–∏ –∑—Ä–æ–±–∏–≤ ${todayEntries} –∑–∞–ø–∏—Å—ñ–≤! üëè\n` +
              `–ß—É–¥–æ–≤–∞ —Ä–æ–±–æ—Ç–∞ –∑ —Ä–æ–∑–≤–∏—Ç–∫—É –∫–∞—Ä–º–∏.\n` +
              `–ü–æ–±–∞–∂–∞–π —Å–æ–±—ñ –¥–æ–±—Ä–∞–Ω—ñ—á —ñ –≥–æ—Ç—É–π—Å—è –¥–æ –Ω–æ–≤–æ–≥–æ –¥–Ω—è! üåü`;
          }

          await bot.sendMessage(
            parseInt(user.telegramId!),
            message,
            {
              reply_markup: {
                inline_keyboard: [
                  [{ text: "üìù –î–æ–¥–∞—Ç–∏ –∑–∞–ø–∏—Å", callback_data: "add_entry" }],
                  [{ text: "üèÜ –ú–æ—ó –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è", callback_data: "achievements" }]
                ]
              }
            }
          );
        } catch (error) {
          console.error(`Failed to send evening reminder to user ${user.id}:`, error);
        }
      }
    }
  }

  async sendCustomReminder(userId: number, message: string) {
    try {
      const user = await storage.getUser(userId);
      if (user && user.telegramId) {
        await bot.sendMessage(
          parseInt(user.telegramId!),
          message,
          {
            reply_markup: {
              inline_keyboard: [
                [{ text: "üì± –í—ñ–¥–∫—Ä–∏—Ç–∏ –¥–æ–¥–∞—Ç–æ–∫", web_app: { url: process.env.FRONTEND_URL } }]
              ]
            }
          }
        );
      }
    } catch (error) {
      console.error(`Failed to send custom reminder to user ${userId}:`, error);
    }
  }
}

export const reminderService = new ReminderService();